function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
var $parcel$global =
typeof globalThis !== 'undefined'
  ? globalThis
  : typeof self !== 'undefined'
  ? self
  : typeof window !== 'undefined'
  ? window
  : typeof global !== 'undefined'
  ? global
  : {};
var $parcel$modules = {};
var $parcel$inits = {};

var parcelRequire = $parcel$global["parcelRequire5546"];
if (parcelRequire == null) {
  parcelRequire = function(id) {
    if (id in $parcel$modules) {
      return $parcel$modules[id].exports;
    }
    if (id in $parcel$inits) {
      var init = $parcel$inits[id];
      delete $parcel$inits[id];
      var module = {id: id, exports: {}};
      $parcel$modules[id] = module;
      init.call(module.exports, module, module.exports);
      return module.exports;
    }
    var err = new Error("Cannot find module '" + id + "'");
    err.code = 'MODULE_NOT_FOUND';
    throw err;
  };

  parcelRequire.register = function register(id, init) {
    $parcel$inits[id] = init;
  };

  $parcel$global["parcelRequire5546"] = parcelRequire;
}
parcelRequire.register("gk9zP", function(module, exports) {

$parcel$export(module.exports, "Util", () => Util);
parcelRequire("bsgU1");

var $lRZZ2 = parcelRequire("lRZZ2");

var $lBIzH = parcelRequire("lBIzH");
class Util {
    static detect_framework() {
        let framework11 = null;
        if (typeof window.nv != "undefined") framework11 = new (0, $lBIzH.NiiVue)(window.nv);
        else if (typeof window.niivue != "undefined") framework11 = new (0, $lBIzH.NiiVue)(window.niivue);
        else if (typeof window.cornerstone != "undefined") framework11 = new (0, $lRZZ2.Cornerstone2D)(window.cornerstone);
        // TODO: fallback to general canvas or webgl framework
        return framework11;
    }
    static async load_script(url) {
        const script = window.document.createElement("script");
        script.type = "text/javascript";
        script.src = url;
        window.document.head.appendChild(script);
        eval(script);
    }
    static async send_http_post(url11, data11, callback11) {
        let xhr11 = new XMLHttpRequest();
        xhr11.open("POST", url11);
        xhr11.onreadystatechange = function() {
            if (xhr11.readyState === 4) {
                // request done
                callback11(xhr11.response);
                return;
            }
        };
        xhr11.send(data11);
    }
    static convert_to_png(uint8array11, width11, height11, flip11) {
        // we are using an offscreen canvas for this
        let offscreen11 = window.document.createElement("canvas");
        offscreen11.width = width11;
        offscreen11.height = height11;
        window.document.body.append(offscreen11);
        let offscreen_ctx11 = offscreen11.getContext("2d");
        let imgdata11 = offscreen_ctx11.createImageData(offscreen11.width, offscreen11.height);
        let pxdata11 = imgdata11.data;
        for(var i11 = 0; i11 < pxdata11.length; i11++)pxdata11[i11] = uint8array11[i11];
        // update canvas with new data
        offscreen_ctx11.putImageData(imgdata11, 0, 0);
        offscreen_ctx11.save();
        if (typeof flip11 != "undefined") offscreen_ctx11.scale(1, -1); // Flip vertically
        let c_height11 = height11;
        if (typeof flip11 != "undefined") c_height11 = -height11;
        offscreen_ctx11.drawImage(offscreen11, 0, c_height11);
        offscreen_ctx11.restore();
        let base6411 = offscreen11.toDataURL("image/png");
        base6411 = base6411.replace("data:image/png;base64,", "");
        let pngpixels11 = Uint8Array.from(atob(base6411), (c11)=>c11.charCodeAt(0));
        return pngpixels11;
    }
}

});
parcelRequire.register("bsgU1", function(module, exports) {

$parcel$export(module.exports, "Framework", () => $0226f559a631e361$export$638889172ebce0c4);

var $gk9zP = parcelRequire("gk9zP");
class $0226f559a631e361$export$638889172ebce0c4 {
    constructor(instance){
        this.name = "generic";
        this.instance = instance;
        this.flip_on_png = false;
    }
    get_current_image() {
        throw "Missing Implementation.";
    }
    select_box(callback) {
        throw "Missing Implementation.";
    }
    convert_to_png(uint8array, width, height) {
        return (0, $gk9zP.Util).convert_to_png(uint8array, width, height, this.flip_on_png);
    }
}

});

parcelRequire.register("lRZZ2", function(module, exports) {

$parcel$export(module.exports, "Cornerstone2D", () => $febea0d4681e2ae0$export$1ec7e9f19103cb25);

var $bsgU1 = parcelRequire("bsgU1");
class $febea0d4681e2ae0$export$1ec7e9f19103cb25 extends (0, $bsgU1.Framework) {
    constructor(instance){
        super(instance);
        this.name = "cornerstone2D";
        this.cornerstonetools_instance = null;
        if (typeof window.cornerstoneTools != "undefined") // TODO probably not too robust
        this.cornerstonetools_instance = window.cornerstoneTools;
        this.flip_on_png = false;
    }
    get_current_image() {
        // TODO this is hacky going through the canvas
        // later should grab the real volume data
        let element = this.instance.getEnabledElements()[0];
        let canvas = element.canvas;
        let height = canvas.height;
        let width = canvas.width;
        let ctx = canvas.getContext("2d");
        let pixels = ctx.getImageData(0, 0, width, height);
        return pixels;
    }
    select_box(callback) {
        this.cornerstonetools_instance.setToolActive("RectangleRoi", {
            mouseButtonMask: 1
        });
        let element = this.instance.getEnabledElements()[0];
        let canvas = element.canvas;
        canvas.onmouseup = (function() {
            let state = this.cornerstonetools_instance.globalImageIdSpecificToolStateManager.saveToolState();
            let topleft = state[Object.keys(state).pop()].RectangleRoi.data[0].handles.start;
            let bottomright = state[Object.keys(state).pop()].RectangleRoi.data[0].handles.end;
            let topleft_c = this.instance.pixelToCanvas(element.element, topleft);
            let bottomright_c = this.instance.pixelToCanvas(element.element, bottomright);
            this.cornerstonetools_instance.clearToolState(element.element, "RectangleRoi");
            this.instance.renderGrayscaleImage(element, true);
            callback(topleft_c, bottomright_c);
        }).bind(this);
    }
}

});

parcelRequire.register("lBIzH", function(module, exports) {

$parcel$export(module.exports, "NiiVue", () => $fbafa14c3ac31938$export$3d6843c2c4a1bd6c);

var $bsgU1 = parcelRequire("bsgU1");
class $fbafa14c3ac31938$export$3d6843c2c4a1bd6c extends (0, $bsgU1.Framework) {
    constructor(instance){
        super(instance);
        this.name = "niivue";
        this.flip_on_png = true;
    }
}

});



var $gk9zP = parcelRequire("gk9zP");
parcelRequire("bsgU1");
class $c41144187e031f80$export$a1c8e230980baa0 {
    constructor(){
        this.framework = null;
    }
    /**
   * Initializes the Boostlet.
   * 
   * This includes several steps such as identifying the 
   * visualization/rendering framework that is available. 
   * 
   * TODO: Later we want to have fallbacks in place if the framework
   * is not detected.
   * 
   */ init(name, instance) {
        if (typeof name != "undefined" && typeof instance != "undefined") {
            console.log("Framework forced by user!");
            throw "Forced Framework Not Implemented.";
        // TODO
        } else this.framework = (0, $gk9zP.Util).detect_framework();
        if (this.framework) console.log("Found", this.framework, "!");
        else throw "Framework Not Found.";
    }
    /**
   * Let's the user select a region of interest box.
   */ async select_box(callback) {
        this.framework.select_box(callback);
    }
    /**
   * Let's the user select (multiple) seeds.
   */ async select_seed(howmany) {
        throw "Missing Implementation.";
    }
    /**
   * Loads an external javascript file asynchronously. 
   */ async load_script(url) {
        (0, $gk9zP.Util).load_script(url);
    }
    /**
   * Sends a HTTP POST request to a url with some data.
   */ async send_http_post(url, data, callback) {
        (0, $gk9zP.Util).send_http_post(url, data, callback);
    }
    /**
   * Gets the current image (2D).
   * 
   * TODO: Optional bounding box should be supported.
   * 
   */ get_current_image() {
        return this.framework.get_current_image();
    }
    /**
   * Encode raw image data to PNG.
   */ convert_to_png(uint8array, width, height) {
        return this.framework.convert_to_png(uint8array, width, height);
    }
}


// register global namespace with a new boostlet instance
// later we might want to support multiple active boostlets
window.Boostlet = new (0, $c41144187e031f80$export$a1c8e230980baa0)();


//# sourceMappingURL=boostlet.min.js.map
