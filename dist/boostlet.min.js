function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
var $parcel$global =
typeof globalThis !== 'undefined'
  ? globalThis
  : typeof self !== 'undefined'
  ? self
  : typeof window !== 'undefined'
  ? window
  : typeof global !== 'undefined'
  ? global
  : {};
var $parcel$modules = {};
var $parcel$inits = {};

var parcelRequire = $parcel$global["parcelRequire5546"];
if (parcelRequire == null) {
  parcelRequire = function(id) {
    if (id in $parcel$modules) {
      return $parcel$modules[id].exports;
    }
    if (id in $parcel$inits) {
      var init = $parcel$inits[id];
      delete $parcel$inits[id];
      var module = {id: id, exports: {}};
      $parcel$modules[id] = module;
      init.call(module.exports, module, module.exports);
      return module.exports;
    }
    var err = new Error("Cannot find module '" + id + "'");
    err.code = 'MODULE_NOT_FOUND';
    throw err;
  };

  parcelRequire.register = function register(id, init) {
    $parcel$inits[id] = init;
  };

  $parcel$global["parcelRequire5546"] = parcelRequire;
}
parcelRequire.register("gPF4j", function(module, exports) {

$parcel$export(module.exports, "Boostlet", () => Boostlet);
parcelRequire("bsgU1");

var $86yTT = parcelRequire("86yTT");
class Boostlet {
    constructor(){
        this.framework = null;
    }
    /**
   * Initializes the Boostlet.
   * 
   * This includes several steps such as identifying the 
   * visualization/rendering framework that is available. 
   * 
   * TODO: Later we want to have fallbacks in place if the framework
   * is not detected.
   * 
   * TODO: We also want to have a force mode where the developer
   * can specify which framework to use as a bypass of the detection.
   * 
   */ init() {
        // TODO: detect which framework is available and pick the first one
        if (typeof window.nv != "undefined") this.framework = new (0, $86yTT.NiiVue)(window.nv);
        else if (typeof window.niivue != "undefined") this.framework = new (0, $86yTT.NiiVue)(window.niivue);
        if (this.framework) console.log("Found", this.framework, "!");
        else // TODO: fallback to general canvas or webgl framework
        throw "Framework Not Found.";
    }
    /**
   * Let's the user select a region of interest box.
   */ async wait_for_box() {
        throw "Missing Implementation.";
    }
    /**
   * Let's the user select (multiple) seeds.
   */ async wait_for_seed(howmany11) {
        throw "Missing Implementation.";
    }
    /**
   * Loads an external javascript file asynchronously. 
   */ load_script(url) {
        const script = window.document.createElement("script");
        script.type = "text/javascript";
        script.src = url;
        window.document.head.appendChild(script);
        eval(script);
    }
    /**
   * Sends a HTTP POST request to a url with some data.
   */ async send_http_post(url11, data11) {
        xhr = new XMLHttpRequest();
        xhr.open("POST", endpoint);
        xhr.onreadystatechange = function() {
            if (xhr.readyState === 4) // request done
            return xhr.response;
        };
        xhr.send(data11);
    }
    /**
   * Gets the current image (2D).
   */ get_current_image() {
        return this.framework.get_current_image();
    }
    /**
   * Encode raw image data to PNG.
   * 
   * TODO: Make flipping optional and dependent on framework.
   */ convert_to_png(uint8array11, width11, height11) {
        // we are using an offscreen canvas for this
        let offscreen11 = window.document.createElement("canvas");
        offscreen11.width = width11;
        offscreen11.height = height11;
        window.document.body.append(offscreen11);
        let offscreen_ctx11 = offscreen11.getContext("2d");
        imgdata = offscreen_ctx11.createImageData(offscreen11.width, offscreen11.height);
        pxdata = imgdata.data;
        for(var i11 = 0; i11 < pxdata.length; i11++)pxdata[i11] = pixels[i11];
        // update canvas with new data
        offscreen_ctx11.putImageData(imgdata, 0, 0);
        offscreen_ctx11.save();
        offscreen_ctx11.scale(1, -1); // Flip vertically
        offscreen_ctx11.drawImage(offscreen11, 0, -c.height); // Draw with flipped coordinates
        offscreen_ctx11.restore();
        base64 = offscreen11.toDataURL("image/png");
        base64 = base64.replace("data:image/png;base64,", "");
        pngpixels = Uint8Array.from(atob(base64), (c11)=>c11.charCodeAt(0));
        return pngpixels;
    }
}

});
parcelRequire.register("bsgU1", function(module, exports) {

$parcel$export(module.exports, "Framework", () => $0226f559a631e361$export$638889172ebce0c4);
class $0226f559a631e361$export$638889172ebce0c4 {
    constructor(instance){
        this.name = "generic";
        this.instance = instance;
    }
}

});

parcelRequire.register("86yTT", function(module, exports) {

$parcel$export(module.exports, "NiiVue", () => $5e69f4c14aa403de$export$3d6843c2c4a1bd6c);

var $bsgU1 = parcelRequire("bsgU1");
class $5e69f4c14aa403de$export$3d6843c2c4a1bd6c extends (0, $bsgU1.Framework) {
    constructor(instance){
        super(instance);
        this.name = "niivue";
    }
}

});



var $gPF4j = parcelRequire("gPF4j");
// register global namespace with a new boostlet instance
// later we might want to support multiple active boostlets
window.Boostlet = new (0, $gPF4j.Boostlet)();


//# sourceMappingURL=boostlet.min.js.map
