function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
var $parcel$global =
typeof globalThis !== 'undefined'
  ? globalThis
  : typeof self !== 'undefined'
  ? self
  : typeof window !== 'undefined'
  ? window
  : typeof global !== 'undefined'
  ? global
  : {};
var $parcel$modules = {};
var $parcel$inits = {};

var parcelRequire = $parcel$global["parcelRequire5546"];
if (parcelRequire == null) {
  parcelRequire = function(id) {
    if (id in $parcel$modules) {
      return $parcel$modules[id].exports;
    }
    if (id in $parcel$inits) {
      var init = $parcel$inits[id];
      delete $parcel$inits[id];
      var module = {id: id, exports: {}};
      $parcel$modules[id] = module;
      init.call(module.exports, module, module.exports);
      return module.exports;
    }
    var err = new Error("Cannot find module '" + id + "'");
    err.code = 'MODULE_NOT_FOUND';
    throw err;
  };

  parcelRequire.register = function register(id, init) {
    $parcel$inits[id] = init;
  };

  $parcel$global["parcelRequire5546"] = parcelRequire;
}
parcelRequire.register("gk9zP", function(module, exports) {

$parcel$export(module.exports, "Util", () => Util);
parcelRequire("bsgU1");

var $hElgO = parcelRequire("hElgO");

var $86yTT = parcelRequire("86yTT");
class Util {
    static detect_framework() {
        let framework11 = null;
        if (typeof window.nv != "undefined") framework11 = new (0, $86yTT.NiiVue)(window.nv);
        else if (typeof window.niivue != "undefined") framework11 = new (0, $86yTT.NiiVue)(window.niivue);
        else if (typeof window.cornerstone != "undefined") framework11 = new (0, $hElgO.Cornerstone2D)(window.cornerstone);
        // TODO: fallback to general canvas or webgl framework
        return framework11;
    }
    static async load_script(url) {
        const script = window.document.createElement("script");
        script.type = "text/javascript";
        script.src = url;
        window.document.head.appendChild(script);
        eval(script);
    }
    static async send_http_post(url11, data11) {
        xhr = new XMLHttpRequest();
        xhr.open("POST", endpoint);
        xhr.onreadystatechange = function() {
            if (xhr.readyState === 4) // request done
            return xhr.response;
        };
        xhr.send(data11);
    }
    static convert_to_png(uint8array11, width11, height11, flip11) {
        console.log("Flipping:", flip11);
        // we are using an offscreen canvas for this
        let offscreen11 = window.document.createElement("canvas");
        offscreen11.width = width11;
        offscreen11.height = height11;
        window.document.body.append(offscreen11);
        let offscreen_ctx11 = offscreen11.getContext("2d");
        let imgdata11 = offscreen_ctx11.createImageData(offscreen11.width, offscreen11.height);
        let pxdata11 = imgdata11.data;
        for(var i11 = 0; i11 < pxdata11.length; i11++)pxdata11[i11] = uint8array11[i11];
        // update canvas with new data
        offscreen_ctx11.putImageData(imgdata11, 0, 0);
        offscreen_ctx11.save();
        if (typeof flip11 != "undefined") offscreen_ctx11.scale(1, -1); // Flip vertically
        let c_height11 = height11;
        if (typeof flip11 != "undefined") c_height11 = -height11;
        offscreen_ctx11.drawImage(offscreen11, 0, c_height11);
        offscreen_ctx11.restore();
        let base6411 = offscreen11.toDataURL("image/png");
        base6411 = base6411.replace("data:image/png;base64,", "");
        let pngpixels11 = Uint8Array.from(atob(base6411), (c11)=>c11.charCodeAt(0));
        return pngpixels11;
    }
}

});
parcelRequire.register("bsgU1", function(module, exports) {

$parcel$export(module.exports, "Framework", () => $0226f559a631e361$export$638889172ebce0c4);

var $gk9zP = parcelRequire("gk9zP");
class $0226f559a631e361$export$638889172ebce0c4 {
    constructor(instance){
        this.name = "generic";
        this.instance = instance;
        this.flip_on_png = false;
    }
    get_current_image() {}
    convert_to_png(uint8array, width, height) {
        return (0, $gk9zP.Util).convert_to_png(uint8array, width, height, this.flip_on_png);
    }
}

});

parcelRequire.register("hElgO", function(module, exports) {

$parcel$export(module.exports, "Cornerstone2D", () => $cd96abe9377b8138$export$1ec7e9f19103cb25);

var $bsgU1 = parcelRequire("bsgU1");
class $cd96abe9377b8138$export$1ec7e9f19103cb25 extends (0, $bsgU1.Framework) {
    constructor(instance){
        super(instance);
        this.name = "cornerstone2D";
        this.flip_on_png = false;
    }
}

});

parcelRequire.register("86yTT", function(module, exports) {

$parcel$export(module.exports, "NiiVue", () => $5e69f4c14aa403de$export$3d6843c2c4a1bd6c);

var $bsgU1 = parcelRequire("bsgU1");
class $5e69f4c14aa403de$export$3d6843c2c4a1bd6c extends (0, $bsgU1.Framework) {
    constructor(instance){
        super(instance);
        this.name = "niivue";
        this.flip_on_png = true;
    }
}

});



var $gk9zP = parcelRequire("gk9zP");
parcelRequire("bsgU1");
parcelRequire("86yTT");
class $c41144187e031f80$export$a1c8e230980baa0 {
    constructor(){
        this.framework = null;
    }
    /**
   * Initializes the Boostlet.
   * 
   * This includes several steps such as identifying the 
   * visualization/rendering framework that is available. 
   * 
   * TODO: Later we want to have fallbacks in place if the framework
   * is not detected.
   * 
   */ init(name, instance) {
        if (typeof name != "undefined" && typeof instance != "undefined") {
            console.log("Framework forced by user!");
            throw "Forced Framework Not Implemented.";
        // TODO
        } else this.framework = (0, $gk9zP.Util).detect_framework();
        if (this.framework) console.log("Found", this.framework, "!");
        else throw "Framework Not Found.";
    }
    /**
   * Let's the user select a region of interest box.
   */ async select_box() {
        throw "Missing Implementation.";
    }
    /**
   * Let's the user select (multiple) seeds.
   */ async select_seed(howmany) {
        throw "Missing Implementation.";
    }
    /**
   * Loads an external javascript file asynchronously. 
   */ async load_script(url) {
        (0, $gk9zP.Util).load_script(url);
    }
    /**
   * Sends a HTTP POST request to a url with some data.
   */ async send_http_post(url, data) {
        (0, $gk9zP.Util).send_http_post(url, data);
    }
    /**
   * Gets the current image (2D).
   * 
   * TODO: Optional bounding box should be supported.
   * 
   */ get_current_image() {
        return this.framework.get_current_image();
    }
    /**
   * Encode raw image data to PNG.
   */ convert_to_png(uint8array, width, height) {
        return this.framework.convert_to_png(uint8array, width, height);
    }
}


// register global namespace with a new boostlet instance
// later we might want to support multiple active boostlets
window.Boostlet = new (0, $c41144187e031f80$export$a1c8e230980baa0)();


//# sourceMappingURL=boostlet.min.js.map
